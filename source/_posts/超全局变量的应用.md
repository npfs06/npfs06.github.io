---
title: 超全局变量$GLOBALS的应用
date: 2020-04-17 23:33:43
updated: 2020-04-17 23:33:43
categories: 
  - [web]
  - [share]
---



PHP中有一个鲜为人知的超全局变量$GLOBALS。<!--more-->

$GLOBALS定义：引用全局作用域中可用的全部变量(一个包含了全部变量的组合数组。变量的名字就是数组的键)，与所有其他超全局变量不同，$GLOBALS在PHP代码中的任何地方都是可用的，可以通过打印$GLOBALS变量查看结果验证。

在PHP生命周期中，定义在函数体外部的全局变量，函数内部是不能直接获得的。如果要在函数体内访问外部定义的全局变量，可以通过global声明或者直接使用$GLOBALS来进行访问。

比如:

```
<?php
$var1='www.tidesec.com';
$var2='www.tidesec.net';
test();
function test(){
$var1='tide';
echo $var1,'<br />';
global $var1;
echo $var1,'<br />';
echo $GLOBALS['var2'];
}
```

输出结果为:

```
tide
www.tidesec.com
www.tidesec.net
```

其中global和$GLOBALS的区别:

$GLOBALS['var']是外部全局变量的本身，而global  $var则是外部$var的同名引用或者说是指针，也就是说global函数产生一个指向函数外部变量的别名变量，而不是真正的函数外部变量，而$GLOBALS[]确确实实调用的是外部的变量，函数内外都会始终保持一致。

举个例子：

```
$var1=tide;
$var2=tidesec;
function test(){
$GLOBALS['var2']=&$GLOBALS['var1'];
}  
test();
echo $var2;
```

结果为:

```
tide
```

------

```
$var1=tide;
$var2=tidesec;
function test(){
global $var1,$var2
$var2=&$var1;
}  
test();
echo $var2;

```

结果为：

```
tidesec
```

结果之所以为tidesec，原因为$var1的引用指向了$var2的引用地址。导致实质的值没有发生变化。

------

```
$var1=tide;
function test(){
global $var1;
unset($var1);
}  
test();
echo $var1;
```

结果为：

```
tide
```

这就说明，删除的只是别名或者说是引用，其本身作用的值没有受到任何的影响。也就是说，global $var其实是$var = &$GLOBALS['var']，调用外部变量的一个别名而已。



---

转载自 https://www.freebuf.com/column/230907.html