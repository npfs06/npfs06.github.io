---
title: Algorithm Collection
date: 2021-07-06 01:07:54
updated: 2021-07-06 01:07:54
categories: 算法
password: Npfs2333
---

2021大二上算法期末复习<!--more-->

**最大子列和（递归）**

1. 输入
2. maxsum(1,n)
     a. 如果只有一个数，输出
     b. 取中间，递归左区间，递归右区间
     c. 求左区间做大和，右区间最大和，及中间最大和；最后找出这三类的最大值

3. 如果为负数，置0  

**杨辉三角（递归）**

```c++
求每一个数
int fun(int i,int j){
    if(j==0||j==i)
        return 1;
    else
        return fun(i-1,j-1)+fun(i-1,j);
}
```



**汉诺塔（递归）**

```c++
hanoi(n-1, a, c, b);
cout <<a << "-->" << b << endl;
hanoi(n-1, c, b, a);
```



**全排列（递归）**

> void perm(int n,int m)；

```c++
每次第一个数和后面的数做交换(第1个数和第1个数做交换，和第2个数做交换，和第3个数做交换....)
for(int i=n;i<=m;i++){
	swap(a[i],a[n]);
	perm(n+1,m);
	swap(a[i],a[n]);
	}
```

当n=m时输出



**循环课程表（递归）**

1. 输入

2. 递归，递归到n=1

3. fun(2/1)

4. 左上给左下赋值;左上给右上赋值;左上给右下赋值

5. 两个if语句，循环输出

   ```c++
   int fun(int n){
         if(n==1) return 0;
   	  else fun(n/2);
   	  for(int i=1;i<=n/2;i++){
   		  for(int j=1;j<=n/2;j++)
   		  {
   		     a[i+n/2][j]=a[i][j]+n/2; //左上给左下赋值
                a[i][j+n/2]=a[i][j]+n/2; //左上给右上赋值
                a[i+n/2][j+n/2]=a[i][j]; //左上给右下赋值
   		  }
   	  }
   	  return 0;
   }
   ```





**p/n棋盘（递归）**

理解和做法上基本和循环课程表相同，这里就不多加赘述
```c++
void check(int a, int b,int c ,int size)
{
    int half;
    if(size==1){   //最优值
        board[a][b]=c;
    }
    else{
        half=size/2;
        check(a,b,c,half);      //以下四个check为最优情况，分别对应四个方位
        check(a,b+half,c,half);
        if(c==1){
            check(a+half,b,0,half);
        }
        else{
            check(a+half,b,1,half);
        }
        check(a+half,b+half,c,half);
    }
}
```

**棋盘覆盖（递归）**

1. chess(a,b,aa,bb,length);
    a,b永远为左上角

2. 递归分割成四小块，将L骨牌覆盖在无特殊点的三个方块的交接处
```c++
    t++;
    int tem =t;
    int l=length/2;
    if(aa<a+l && bb<b+l){ //特殊点在左上的正方形中
        chess(a,b,aa,bb,l);
    }
    else{
        def[a+l-1][b+l-1]=tem;
        //cout<<"左上  "<<l<<"  "<<l<<"  "<<def[l][l]<<endl;
        chess(a,b,a+l-1,b+l-1,l);
    }
```

**二叉树遍历（递归）**
1. 结合中序遍历，找层次遍历中优先输出根节点的位置，假设根节点在中序遍历结果中排在第j个、

```c++
void find(int l1,int r1,int l2,int r2)   //r1中序遍历序列长度减一(因为数组从0开始)，r2按层遍历序列长度减一

......

    if(j>l1)    //当根节点在第一个时j<=l1,此时说明只存在右子树
        find(l1,j-1,0,r2);//遍历左子树 
    if(j<r1)    //当根节点在最后一个时j>=r1,此时说明只存在左子树
        find(j+1,r1,0,r2);//遍历右子树 
```

**数的划分（动态规划）**
分为两种情况
1. 拆分为1个树相加，b[i][1]=1

2. 拆分为k（k>=2）个数相加,b[i][j]=b[i-j][j]+b[i][j-1]
    即有0和无0的情况相加
  ```c++
  	for(int i=1;i<=n;i++) bit[i][1]=1;   //一组K=1的情况
	for(int i=1;i<=n;i++){
		for (int j = 2; j <= k; j++)   //大于等于2组k>=2的情况
		{
			bit[i][j]=bit[i-j][j]+bit[i][j-1];
		}
		
	}
  ```

**矩阵连乘（动态规划）**

左上角到右下角
```c++
void MatrixChain(int n){
	for(int i = 1; i <= n; i++) 
        m[i][i] = 0;
	for(int r = 2; r <= n; r++){
		for(int i = 1; i <= n-r+1; i++){
			int j = i + r - 1;
			m[i][j] = INF;
			for(int k = i; k <= j-1; k++){
				int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
				if(t < m[i][j]){
					m[i][j] = t;
					s[i][j] = k;
				}
			}
		}
	}
}
```

**LIS（动态规划）**
```c++
    for(int j=2;j<n;j++){
        for (int k = 1; k < j; k++)
        {
            if(b[j]>b[k])
                max_len[j]=max(max_len[j],max_len[k]+1);         //核心代码14-19
        }
   
    }
```

**LCS（动态规划）**
1. 设第一个字串长度n,第二个长度m

2. n[i]==m[j],则为左上角加一，否则去右边或上边第一个的最大值

**0/1背包（动态规划）**
```c++
    //以下算法的作用就是填表，最后求出m[i][j]的值
    for(int i=1;i<=n;i++){    //遍历物品
    	for(int j=1;j<=c;j++){         //表的横轴，假设背包最大容量从1开始递增
    		if(j>=w[i])    //j>=w[i]代表当前背包容量能容纳第i个物品的重量
    			m[i][j]=max(m[i-1][j-w[i]]+v[i],m[i-1][j]);   //两种情况，第一种是将当前物品放入背包，丢到前一个物品；第二种情况是丢到当前物品
    		else
    			m[i][j]=m[i-1][j];   //当前背包容量不能容纳第i个物品的重量
		}
	}
```

**完全背包（动态规划）**
和01背包没什么区别
唯一区别如下
> m[i][j]=max(m[i][j-w[i]]+v[i],m[i-1][j]);

**单源最短路径（贪心）**
1. 将任意两城市间的距离设为无穷

2. 输入距离并更新

3. 将所有城市和到城市1的距离赋值给dis[i],并求出最小dis，同时将最小距离城市的vis[i]=1

4. 将最小dis的那个城市i作为源点，更新dis，重复步骤3

**活动安排（贪心）**
1. 按结束时间升序排序

2. 选择开始时间大于前一个选定的结束时间的活动

**过河问题（贪心）**
1. 先将最慢的两个人送过河
```c++
        while(n > 3)
        {
            sum += min( pep[0]*2 + pep[n-1] + pep[n-2] , pep[n-1] + pep[1]*2 + pep[0] );   //讲过河最慢的两个人送过河
            n -= 2;
        }
        if(n == 3)
        {
            sum += pep[2] + pep[0] +pep[1];
        }
        if(n == 2)
        {
            sum +=  pep[1];
        }
        if(n == 1)
        {
            sum += pep[0];
        }
```

**全排列（回溯）**
dp从1到n，执行n次，每次选择一个数 
```c++
	for(int i=1;i<=n;i++)   
	{
		if(!v[i])  //没有被选过的数
		{
			a[dp]=i;
			v[i]=1;   //选择
			dfs(dp+1);
			v[i]=0;   //撤销
		}
	}
```

**N皇后（回溯）**

1. 一行一行判断

2. 第一行从第一列开始放，放了之后check，通过则跳到下一行

3. 全部放完之后输出

```c++
int check(int t){
    for(int i = 1; i < t; i++){  //因为按行放的皇后，所以不用检测同行(t是列名)
        if(abs(i - t) == abs(x[i] - x[t]) || x[i] == x[t]) return 0;  // x[i] == x[t]是列相等判断；abs(i - t) == abs(x[i] - x[t])是对角线相等判断
    }
    return 1;
} 
```

**逆序数（回溯）**

回溯求全排列，暴力求取逆序数

**整数拆分（回溯）**
```c++
#include <iostream>
using namespace std;
int x[20], n, dep, cnt;

int f(int r,int t) {
    if (r==0) {      //输出条件，输入的数都被分完
        cout << n << "=";
        for (int j = 1; j < t-1; j++) {
            cout << x[j] << "+";
        }
        cout << x[t - 1]<<endl;
        cnt++;
        return cnt;
    }
    else
        for (int j = x[t - 1]; j <= r; j++) {
            if (j < r) {
                x[t] = j;
                f(r - j, t + 1);
            }
        }
}

int main() {
    cin >> n;
    x[0] = 1; 
    f(n,1);
    cout << cnt;
    return 0;
}

```
**装载问题（回溯）**
```c++
 void backtrack(int i){  
     int j;  
     if(i>n){  
         if(cw>bw){  
             bw=cw;  
         }  
         return ;  
     }  
     r-=w[i];  
     if(cw+w[i]<=c1){   
         cw+=w[i];  
         flag[i]=1;  
         backtrack(i+1);  
         cw-=w[i];  
         flag[i]=0;  
     }  
     if(cw+r>bw){  
         backtrack(i+1);  
     }   
     r+=w[i];  
 }  
```